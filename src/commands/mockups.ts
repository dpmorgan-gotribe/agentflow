import { readFile, writeFile, mkdir, readdir } from 'fs/promises';
import { join } from 'path';
import { validateAndCleanHTML } from '../lib/validation.js';
import { loadSystemPrompt, loadSkill } from '../lib/agent.js';
import { runWorkersParallel } from '../lib/worker.js';
import { detectPlatforms, getSharedAnalysisDir } from '../lib/platforms.js';

// Extract asset mode from styles.md metadata comment
function extractAssetMode(stylesContent: string): 'useAssets' | 'standard' {
  const match = stylesContent.match(/<!--\s*assetMode:\s*(useAssets|standard)\s*-->/);
  return match && match[1] === 'useAssets' ? 'useAssets' : 'standard';
}

// Scan user asset directories
async function scanAssets(projectDir: string) {
  const scan = async (subdir: string) => {
    try {
      return await readdir(join(projectDir, 'assets', subdir));
    } catch {
      return [];
    }
  };

  return {
    logos: await scan('logos'),
    icons: await scan('icons'),
    wireframes: await scan('wireframes')
  };
}

export async function mockups() {
  const projectDir = process.cwd();

  // Detect if multi-platform project (for analysis directory structure)
  const platforms = await detectPlatforms(projectDir);
  const isMultiPlatform = platforms.length > 0;

  console.log('Generating style mockups...');

  // Scan user asset directories
  const userAssets = await scanAssets(projectDir);
  console.log(`Found assets: ${userAssets.logos.length} logo(s), ${userAssets.icons.length} icon(s), ${userAssets.wireframes.length} wireframe(s)`);

  // Determine analysis directory (shared if multi-platform)
  const analysisDir = isMultiPlatform
    ? getSharedAnalysisDir(projectDir)
    : join(projectDir, 'outputs', 'analysis');

  // Load analysis outputs
  let stylesContent: string;
  let componentsContent: string = '';
  let inspirationsContent: string;
  let assetsContent: string = '';

  try {
    stylesContent = await readFile(join(analysisDir, 'styles.md'), 'utf-8');

    // Load components from first available screens.json (mockups are style previews, not platform-specific)
    if (isMultiPlatform && platforms.length > 0) {
      for (const p of platforms) {
        try {
          const screensJson = await readFile(join(projectDir, 'outputs', 'analysis', p, 'screens.json'), 'utf-8');
          const screensData = JSON.parse(screensJson);
          if (screensData.components) {
            componentsContent = `## Required Components\n${screensData.components.join(', ')}`;
            break; // Use first available
          }
        } catch {
          // Try next platform
        }
      }
    } else {
      try {
        const screensJson = await readFile(join(analysisDir, 'screens.json'), 'utf-8');
        const screensData = JSON.parse(screensJson);
        if (screensData.components) {
          componentsContent = `## Required Components\n${screensData.components.join(', ')}`;
        }
      } catch {
        // No screens.json yet - that's ok for mockups
      }
    }

    inspirationsContent = await readFile(join(analysisDir, 'inspirations.md'), 'utf-8');
  } catch {
    console.error('Analysis outputs not found.');
    console.error('Run `agentflow analyze` first.');
    process.exit(1);
  }

  // Load assets.md (optional)
  try {
    assetsContent = await readFile(join(analysisDir, 'assets.md'), 'utf-8');
  } catch {
    // Continue without assets.md
  }

  // Detect asset mode from styles.md metadata
  const assetMode = extractAssetMode(stylesContent);
  if (assetMode === 'useAssets') {
    console.log('Asset mode: useAssets (all styles use user assets)');
  } else {
    console.log('Asset mode: standard (style 0 uses user assets, others use library icons)');
  }

  // Detect how many styles were generated by checking assets/styles/ directories
  let styleCount = 1;
  try {
    const stylesDir = join(projectDir, 'assets', 'styles');
    const dirs = await readdir(stylesDir);
    const styleDirs = dirs.filter(d => d.startsWith('style-'));
    styleCount = styleDirs.length;
  } catch {
    // Fall back to parsing styles.md for "## Style N:" headers
    const styleMatches = stylesContent.match(/## Style \d+:/g);
    if (styleMatches) {
      styleCount = styleMatches.length;
    }
  }

  console.log(`Generating ${styleCount} mockup(s)...`);

  // Load skill and system prompt
  const systemPrompt = await loadSystemPrompt(projectDir, 'ui-designer');
  const skill = await loadSkill(projectDir, 'design/design-mockup');

  // Build logo section (applies to ALL styles)
  // Path: outputs/mockups/style-N.html -> ../../assets/logos/ (2 levels up)
  const logoSection = userAssets.logos.length > 0
    ? `## User Logo (REQUIRED - USE THIS IN ALL MOCKUPS)
The user has provided a logo. You MUST include it in the header/navigation:
${userAssets.logos.map(f => `- ../../assets/logos/${f}`).join('\n')}

Include the logo using:
<img src="../../assets/logos/${userAssets.logos[0]}" alt="Logo" class="logo" style="height: 32px;" />`
    : '';

  // Build icon section for user icons
  // Path: outputs/mockups/style-N.html -> ../../assets/icons/ (2 levels up)
  const userIconSection = userAssets.icons.length > 0
    ? `## User Icons (Use these existing icons)
Available icons in ../../assets/icons/:
${userAssets.icons.map(f => `- ${f}`).join('\n')}

Reference with: <img src="../../assets/icons/[filename]" alt="..." />`
    : '';

  // Create worker tasks (one per style: 0, 1, 2, ...)
  const workerTasks = [];

  for (let i = 0; i < styleCount; i++) {
    const isStyle0 = i === 0;
    const useUserAssets = isStyle0 || assetMode === 'useAssets';

    // Style-specific asset instructions
    let assetInstructions: string;

    if (useUserAssets && userAssets.icons.length > 0) {
      assetInstructions = `## Style ${i} Asset Instructions
- Use the user's icons from assets/icons/ (paths listed below)
- Follow the style's color palette and typography
${isStyle0 ? '- Follow the "Layout Patterns" section in Style 0 definition from styles.md' : ''}

${userIconSection}`;
    } else {
      assetInstructions = `## Style ${i} Asset Instructions
- Use icons from a recommended icon library (Lucide, Heroicons, Phosphor, or Feather)
- Include a comment with the icon library link: <!-- Icons: https://lucide.dev -->
- Apply the style's unique color palette and typography`;
    }

    // Build user prompt
    const userPrompt = `Create a mockup for Style ${i}.

CRITICAL: Output ONLY raw HTML. Start with <!DOCTYPE html> and end with </html>.
No explanations. No descriptions. No markdown. Just complete, valid HTML.

${logoSection}

${assetInstructions}

## Asset Inventory
${assetsContent || 'No asset inventory available.'}

## Style Definitions
${stylesContent}

## Components Available
${componentsContent}

## Design Inspirations
${inspirationsContent}

## Instructions
- Find "## Style ${i}:" in the style definitions above
- Create an HTML mockup that demonstrates this style
${isStyle0 ? '- Follow the "Layout Patterns" section for navigation and screen structure' : ''}
${useUserAssets && userAssets.icons.length > 0 ? '- Use user icons from assets/icons/ as listed above' : ''}
- Use the colors, typography, and spacing from Style ${i}
- Reference the inspirations for visual guidance
${userAssets.logos.length > 0 ? '- MUST include the user logo in the header' : ''}

Remember: Output ONLY the HTML. Nothing else.`;

    workerTasks.push({
      id: `style-${i}`,
      systemPrompt: `${systemPrompt}\n\n## Skill\n\n${skill}`,
      userPrompt
    });
  }

  // Run workers in parallel
  const results = await runWorkersParallel(workerTasks);

  // Write outputs to generic mockups directory (mockups are style previews, not platform-specific)
  const outputDir = join(projectDir, 'outputs', 'mockups');

  await mkdir(outputDir, { recursive: true });

  let successCount = 0;
  let failCount = 0;

  for (const result of results) {
    if (result.output) {
      const validation = validateAndCleanHTML(result.output);

      if (validation.valid) {
        await writeFile(
          join(outputDir, `${result.id}.html`),
          validation.content
        );
        successCount++;
        if (validation.extracted) {
          console.log(`  ${result.id}: extracted HTML from mixed output`);
        }
      } else {
        console.warn(`  ${result.id}: validation failed - ${validation.errors.join(', ')}`);
        // Still write the cleaned content for debugging
        await writeFile(
          join(outputDir, `${result.id}.html`),
          validation.content
        );
        failCount++;
      }
    }
  }

  if (failCount > 0) {
    console.warn(`\nWarning: ${failCount} mockup(s) may have invalid HTML`);
  }

  const styleList = Array.from({ length: styleCount }, (_, i) => `  - style-${i}.html`).join('\n');

  console.log(`
Style mockups complete!

Outputs written to outputs/mockups/
${styleList}

Next: Review and pick a style, then run:
  agentflow stylesheet --style=N${isMultiPlatform ? ' --platform=<platform>' : ''}
`);
}
